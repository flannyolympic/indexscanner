import logging import random import sqlite3 import time as t_module from
datetime import datetime, time, timedelta import numpy as np import pandas as pd
import pytz import requests import yfinance as yf from flask import ( Flask,
jsonify, redirect, render_template, request, url_for, ) from scipy.stats import
norm app = Flask(__name__) DB_NAME = "watchlist.db" # Logging
logging.basicConfig(level=logging.INFO) logger =
logging.getLogger("HFT_Scanner") # VIX Cache VIX_CACHE = { "data": {"price":
"WAIT", "color": "grey", "label": "INITIALIZING", "market_status": "grey"},
"last_updated": 0 } # Universe updated to focus on Checklist Tickers (SPY, QQQ)
+ High Volume UNIVERSE = [ "SPY", "QQQ", "IWM", "NVDA", "TSLA", "AAPL", "MSFT",
"AMD", "AMZN", "GOOGL", "META", "BTC-USD", "ETH-USD", "SOL-USD", "COIN", "MSTR",
"GME", "AMC" ] def init_db(): conn = sqlite3.connect(DB_NAME,
check_same_thread=False) c = conn.cursor() c.execute("""CREATE TABLE IF NOT
EXISTS watchlist (id INTEGER PRIMARY KEY, ticker TEXT, signal TEXT, price REAL,
strategy TEXT, timestamp DATETIME DEFAULT CURRENT_TIMESTAMP)""") conn.commit()
conn.close() init_db() # --- HELPERS --- def get_current_time_est(): return
datetime.now(pytz.timezone("US/Eastern")) def get_market_status_color(): now =
get_current_time_est() if now.weekday() >= 5: return "#ff5252" # Weekend Red
current_time = now.time() # Market Open 9:30 AM - 4:00 PM EST if time(9, 30) <=
current_time <= time(16, 0): return "#00e676" # Green return "#ff5252" # Closed
def get_market_data(ticker): try: # Fetch 1 day of 1m data for precise VWAP/ORB
calculation # Fetch 5 days of 5m data for trend df = yf.download(ticker,
period="5d", interval="5m", progress=False) if isinstance(df.columns,
pd.MultiIndex): df.columns = df.columns.get_level_values(0) if df.empty or
len(df) < 20: return None return df except Exception as e: logger.error(f"Data
fetch error for {ticker}: {e}") return None # --- TECHNICAL INDICATORS (FROM
CHECKLIST) --- def calculate_vwap(df): # VWAP = Cumulative(Price * Volume) /
Cumulative(Volume) # Reset VWAP daily (simplify by taking last 78 bars for
approx 1 day on 5m chart) df_today = df.tail(78).copy() df_today['VWAP'] =
(df_today['Close'] * df_today['Volume']).cumsum() / df_today['Volume'].cumsum()
return df_today['VWAP'].iloc[-1] def calculate_ema(df, span=9): return
df['Close'].ewm(span=span, adjust=False).mean().iloc[-1] def check_orb(df): #
Open Range Breakout (First 30 mins) # Approximation using last few bars if
market just opened # Real ORB requires storing 9:30-10:00 range. # We will use
recent High/Low as proxy for intraday range recent = df.tail(12) # Last hour
high = recent['High'].max() low = recent['Low'].min() current =
df['Close'].iloc[-1] if current > high: return "ORB BREAKOUT" if current < low:
return "ORB BREAKDOWN" return "INSIDE RANGE" # --- STRATEGY ENGINE --- def
analyze_ticker(ticker_input): ticker = ticker_input.upper().strip() df =
get_market_data(ticker) if df is None: if not ticker.endswith("-USD"): df =
get_market_data(f"{ticker}-USD") if df is not None: ticker = f"{ticker}-USD" if
df is None: return None # Calculate Standard Indicators df["SMA_20"] =
df["Close"].rolling(window=20).mean() df["Std_Dev"] =
df["Close"].rolling(window=20).std() df["BB_Upper"] = df["SMA_20"] +
(df["Std_Dev"] * 2) df["BB_Lower"] = df["SMA_20"] - (df["Std_Dev"] * 2) # RSI
delta = df["Close"].diff(1) gain = (delta.where(delta > 0,
0)).rolling(window=14).mean() loss = (-delta.where(delta < 0,
0)).rolling(window=14).mean() rs = gain / loss df["RSI"] = 100 - (100 / (1 +
rs)) # --- CHECKLIST LOGIC INTEGRATION --- latest = df.iloc[-1] price =
latest["Close"] vwap = calculate_vwap(df) ema_9 = calculate_ema(df, 9)
orb_status = check_orb(df) # 0DTE Checklist: Trend & VWAP # "VWAP Reclaim" =
Price crossed above VWAP # "VWAP Reject" = Price crossed below VWAP prev_price =
df['Close'].iloc[-2] setup_name = "Neutral" signal = "NEUTRAL" trend = "FLAT" #
LOGIC: 0DTE CHECKLIST if price > vwap and price > ema_9: signal = "BULLISH"
trend = "LONG" if prev_price < vwap: setup_name = "VWAP RECLAIM" elif prev_price
< ema_9: setup_name = "EMA PULLBACK" elif orb_status == "ORB BREAKOUT":
setup_name = "ORB BREAKOUT" else: setup_name = "TREND MOMENTUM" elif price <
vwap and price < ema_9: signal = "BEARISH" trend = "SHORT" if prev_price > vwap:
setup_name = "VWAP REJECT" elif prev_price > ema_9: setup_name = "EMA REJECT"
elif orb_status == "ORB BREAKDOWN": setup_name = "ORB BREAKDOWN" else:
setup_name = "TREND MOMENTUM" # Contract Selection (From Checklist: ATM / 1 ITM,
Delta 0.35-0.55) # We can't fetch real-time Delta without paid API, but we can
suggest Strike strike_suggestion = "" if trend == "LONG": strike_suggestion =
f"Call ${np.floor(price)} (ATM)" elif trend == "SHORT": strike_suggestion =
f"Put ${np.ceil(price)} (ATM)" # Time Kill Switch (From Checklist: Exit by
1:30-2:00 PM) now_est = get_current_time_est() time_warning = "" if now_est.hour
>= 13 and now_est.minute >= 30: time_warning = " âš ï¸ TIME KILL SWITCH" # Stop
Loss Rules (From Checklist) stop_loss_text = "-40% to -50% Premium" setup_text =
{ "type": setup_name + time_warning, "entry": strike_suggestion, "target": "20%
- 30% Profit", # Standard scalping target "stop": stop_loss_text } # Probability
(Visual Jitter) probability = calculate_probability(price, latest["BB_Upper"] if
trend == "LONG" else latest["BB_Lower"], latest["Std_Dev"], latest["RSI"],
trend) # Social Sentiment (Visual) social = get_social_sentiment(latest["RSI"],
latest["Volume"] > df["Volume"].mean()) return { "ticker": ticker, "price":
round(price, 2), "rsi": round(latest["RSI"], 2), "vwap": round(vwap, 2),
"signal": signal, "suggestion": setup_name, "probability": probability,
"social": social, "setup": setup_text } def calculate_probability(price, target,
std_dev, rsi, trend): # Simple probability mock based on Bollinger Band
proximity safe_vol = max(std_dev, price * 0.005) z_score = abs(target - price) /
(safe_vol * np.sqrt(3)) stat_prob = 2 * norm.sf(z_score) * 100 if trend ==
"LONG" and rsi < 40: stat_prob += 15 elif trend == "SHORT" and rsi > 60:
stat_prob += 15 return round(min(max(stat_prob, 35.5), 96.2), 1) def
get_social_sentiment(rsi, high_vol): if rsi > 75: return {"score": "FOMO",
"comment": "Overextended", "icon": "ðŸ”¥"} if rsi < 25: return {"score": "FEAR",
"comment": "Oversold", "icon": "ðŸ©¸"} if high_vol: return {"score": "HYPE",
"comment": "High Vol", "icon": "ðŸ‘€"} return {"score": "QUIET", "comment":
"Chop", "icon": "ðŸ’¤"} # --- VIX DATA (EXACT MATCH TO IMAGE) --- def
get_vix_data(): global VIX_CACHE if t_module.time() - VIX_CACHE["last_updated"]
< 60: return VIX_CACHE["data"] try: status_color = get_market_status_color() df
= get_market_data("^VIX") if df is None: if VIX_CACHE["last_updated"] > 0:
return VIX_CACHE["data"] return {"price": "ERR", "color": "grey", "label":
"OFFLINE", "market_status": status_color} price = df.iloc[-1]["Close"] # LOGIC
FROM "VIX INDEX RANGES" IMAGE if price < 12: color = "#00E676" # Bright Green
label = "COMPLACENCY ZONE" elif 12 <= price < 15: color = "#66BB6A" # Healthy
Green label = "CALM / HEALTHY" elif 15 <= price < 20: color = "#FFD600" # Gold
label = "MILD CONCERN" elif 20 <= price < 30: color = "#FF9100" # Orange label =
"ELEVATED FEAR" elif 30 <= price < 40: color = "#FF3D00" # Dark Orange label =
"HIGH ANXIETY" elif 40 <= price < 50: color = "#D50000" # Red label = "CRISIS
MODE" else: # 50+ color = "#880E4F" # Maroon label = "SYSTEM SHOCK" new_data = {
"price": round(price, 2), "color": color, "label": label, "market_status":
status_color } VIX_CACHE["data"] = new_data VIX_CACHE["last_updated"] =
t_module.time() return new_data except Exception: return VIX_CACHE["data"]
@app.route("/suggest") def suggest(): query = request.args.get("q", "") if not
query: return jsonify([]) headers = {"User-Agent": "Mozilla/5.0"} url =
f"https://query2.finance.yahoo.com/v1/finance/search?q={query}&quotesCount=5&newsCount=0"
try: response = requests.get(url, headers=headers) data = response.json()
suggestions = [] if "quotes" in data: for item in data["quotes"]: if "symbol" in
item: suggestions.append({"symbol": item["symbol"], "name":
item.get("shortname", item.get("longname", "")), "exch": item.get("exchDisp",
item.get("exchange", ""))}) return jsonify(suggestions) except: return
jsonify([]) @app.after_request def add_header(response): if
request.path.startswith('/static'): response.headers["Cache-Control"] = "public,
max-age=31536000" else: response.headers["Cache-Control"] = "no-cache, no-store,
must-revalidate" response.headers["Pragma"] = "no-cache" return response
@app.route("/") def index(): return render_template("index.html",
vix=get_vix_data(), status_color=get_market_status_color(),
timestamp=get_current_time_est().strftime("%H:%M:%S EST")) @app.route("/scan")
def scan(): start_time = t_module.time() scan_list = random.sample(UNIVERSE, 8)
# Always include SPY/QQQ for 0DTE checklist if "SPY" not in scan_list:
scan_list[0] = "SPY" if "QQQ" not in scan_list: scan_list[1] = "QQQ" raw_results
= [analyze_ticker(t) for t in scan_list] results = [r for r in raw_results if r]
active_setups = [r for r in results if r["signal"] != "NEUTRAL"] chosen_one =
sorted(active_setups, key=lambda x: x["probability"], reverse=True)[0] if
active_setups else (results[0] if results else None) bulls = sum(1 for r in
results if "BULLISH" in r["signal"]) bears = sum(1 for r in results if "BEARISH"
in r["signal"]) mood = "BULL" if bulls > bears else "BEAR" elapsed =
round(t_module.time() - start_time, 2) logger.info(f"Scan complete in
{elapsed}s") return render_template("index.html", results=results,
chosen_one=chosen_one, mood=mood, vix=get_vix_data(),
status_color=get_market_status_color(),
timestamp=get_current_time_est().strftime("%H:%M:%S EST")) @app.route("/search",
methods=["POST"]) def search(): query = request.form.get("query") if not query:
return redirect(url_for("index")) result = analyze_ticker(query) if result is
None: return render_template("index.html", results=[], error=f"Could not find
'{query}'", vix=get_vix_data(), status_color=get_market_status_color(),
timestamp=get_current_time_est().strftime("%H:%M:%S EST")) mood = "BULL" if
"BULLISH" in result["signal"] else "BEAR" if "BEARISH" in result["signal"] else
"NEUTRAL" return render_template("index.html", results=[result],
chosen_one=result, mood=mood, vix=get_vix_data(),
status_color=get_market_status_color(),
timestamp=get_current_time_est().strftime("%H:%M:%S EST"))
@app.route("/api/vix") def api_vix(): return jsonify(get_vix_data()) if __name__
== "__main__": app.run(debug=True)
